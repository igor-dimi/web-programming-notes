# Preface {.unnumbered}

This is a Quarto book.

To learn more about Quarto books visit <https://quarto.org/docs/books>.


## Oscillating Pendulum (drag the bob)

::: {=html}
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>

<div id="pendulum-container"></div>

<script>
new p5(function(p) {
  let originX, originY;
  let r = 140;                 // arm length (pixels)
  let angle = Math.PI / 4;     // initial angle (radians)
  let aVel = 0.0;              // angular velocity
  let aAcc = 0.0;              // angular acceleration
  let gravity = 0.4;           // "g" (tune for feel)
  let damping = 0.995;         // energy loss per frame
  let bobRadius = 18;
  let isDragging = false;

  p.setup = function() {
    const canvas = p.createCanvas(460, 320);
    canvas.parent("pendulum-container");
    originX = p.width / 2;
    originY = 40;
  };

  p.draw = function() {
    p.background(245);

    if (!isDragging) {
      // Simple pendulum dynamics: alpha = -(g/r) * sin(theta)
      aAcc = (-gravity / r) * Math.sin(angle);
      aVel += aAcc;
      aVel *= damping;
      angle += aVel;
    }

    const bobX = originX + r * Math.sin(angle);
    const bobY = originY + r * Math.cos(angle);

    // String
    p.stroke(0);
    p.line(originX, originY, bobX, bobY);

    // Pivot
    p.fill(0);
    p.circle(originX, originY, 6);

    // Bob
    p.fill(isDragging ? 200 : 0);
    p.stroke(0);
    p.circle(bobX, bobY, bobRadius * 2);

    // Hint
    p.noStroke();
    p.fill(60);
    p.text("Drag the bob to set the angle", 12, p.height - 12);
  };

  // Helper: current bob position
  function bobPos() {
    return {
      x: originX + r * Math.sin(angle),
      y: originY + r * Math.cos(angle)
    };
  }

  // Convert pointer position to angle (angle measured from vertical)
  function angleFromPointer(mx, my) {
    // We defined bobX = originX + r*sin(angle), bobY = originY + r*cos(angle)
    // => angle = atan2(dx, dy)
    const dx = mx - originX;
    const dy = my - originY;
    return Math.atan2(dx, dy);
  }

  // Mouse interactions
  p.mousePressed = function() {
    const { x, y } = bobPos();
    if (p.dist(p.mouseX, p.mouseY, x, y) <= bobRadius + 4) {
      isDragging = true;
      aVel = 0; // stop motion while grabbing
    }
  };

  p.mouseDragged = function() {
    if (isDragging) {
      angle = angleFromPointer(p.mouseX, p.mouseY);
    }
  };

  p.mouseReleased = function() {
    if (isDragging) isDragging = false;
  };

  // Touch interactions (mobile)
  p.touchStarted = function() {
    // Mirror mousePressed logic
    const { x, y } = bobPos();
    if (p.dist(p.mouseX, p.mouseY, x, y) <= bobRadius + 4) {
      isDragging = true;
      aVel = 0;
    }
  };

  p.touchMoved = function() {
    if (isDragging) {
      angle = angleFromPointer(p.mouseX, p.mouseY);
    }
  };

  p.touchEnded = function() {
    if (isDragging) isDragging = false;
  };
});
</script>
:::

